"use strict";(self.webpackChunkbifrost_documentation=self.webpackChunkbifrost_documentation||[]).push([[302],{3480:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>d});var i=n(5893),s=n(1151);const o={},r="Ledger",a={id:"concepts/ledger",title:"Ledger",description:"The set of rules that blockchain users must follow.",source:"@site/docs/concepts/ledger.md",sourceDirName:"concepts",slug:"/concepts/ledger",permalink:"/Bifrost/docs/current/concepts/ledger",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"conceptsSidebar",previous:{title:"Consensus",permalink:"/Bifrost/docs/current/concepts/consensus"},next:{title:"P2P",permalink:"/Bifrost/docs/current/concepts/p2p"}},c={},d=[{value:"Core Responsibilities",id:"core-responsibilities",level:2},{value:"Transaction Syntax",id:"transaction-syntax",level:3},{value:"Mempool",id:"mempool",level:3},{value:"Box State",id:"box-state",level:3},{value:"Authorization",id:"authorization",level:3},{value:"Cost and Rewards",id:"cost-and-rewards",level:3}];function l(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"ledger",children:"Ledger"}),"\n",(0,i.jsx)(t.p,{children:"The set of rules that blockchain users must follow."}),"\n",(0,i.jsx)(t.h2,{id:"core-responsibilities",children:"Core Responsibilities"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Verify correct syntax of transactions"}),"\n",(0,i.jsx)(t.li,{children:'Maintain a set of "unconfirmed" transactions'}),"\n",(0,i.jsx)(t.li,{children:"Prohibit spending non-existent tokens"}),"\n",(0,i.jsx)(t.li,{children:"Ensure proper authorization when spending tokens"}),"\n",(0,i.jsx)(t.li,{children:"Calculate transaction costs and rewards"}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"transaction-syntax",children:"Transaction Syntax"}),"\n",(0,i.jsx)(t.p,{children:"Transactions must satisfy a basic set of syntax rules, such as transaction size, timestamp, and quantity validation."}),"\n",(0,i.jsx)(t.p,{children:"The exact rules are defined in BramblSc and used directly in this protocol."}),"\n",(0,i.jsxs)(t.p,{children:["A notable distinction about the transactions of this protocol: SpentTransactionOutputs (transaction inputs) embed a copy of the ",(0,i.jsx)(t.code,{children:"Value"})," of the UTxO to be spent. This results in increased data/storage/transfer but reduces validation costs."]}),"\n",(0,i.jsx)(t.h3,{id:"mempool",children:"Mempool"}),"\n",(0,i.jsx)(t.p,{children:"Temporarily holds transactions until they are included in a block.  If a transaction is not included after a certain period of time, it is expired from the mempool."}),"\n",(0,i.jsx)(t.p,{children:"All transactions are expected to undergo syntax validation prior to inclusion in the mempool.  Attempting to add to the mempool may perform additional checks (semantic and authorization) depending on the current size of the mempool."}),"\n",(0,i.jsx)(t.p,{children:"Adding a transaction to the mempool will insert it into a graph-like structure based on the UTxOs that are spent. Future maintainers of this part of the system might consider improving the graph implementation.  Additionally, mempool and block production tend to be tightly coupled, so those systems could be merged into one."}),"\n",(0,i.jsx)(t.h3,{id:"box-state",children:"Box State"}),"\n",(0,i.jsx)(t.p,{children:'The term "box" is a bit overloaded in this protocol, but in this context, it essentially just means UTxO (Unspent Transaction Output).  BoxState tracks the state of UTxOs in the ledger. At "genesis", BoxState contains an initial set of UTxOs. A transaction will spend "spend" at least one of those UTxOs and create 0+ new UTxOs.  As transactions are included in blocks, the BoxState is updated accordingly.'}),"\n",(0,i.jsx)(t.p,{children:"If a transaction attempts to spend a Transaction Output that does not exist in BoxState, it is rejected.  Generally, this implies the token was already spent (Double Spend), but it could simply mean that the token never existed at all.  Under the current implementation, there's no distinction."}),"\n",(0,i.jsx)(t.h3,{id:"authorization",children:"Authorization"}),"\n",(0,i.jsx)(t.p,{children:'The blockchain ledger is generally publicly readable, but modifying it requires permission. Permissions are established by the users using "Locks".  A lock requires a very specific "key" in order to be unlocked (although in this case, "key" is much broader than the term used in general cryptography).  When creating a new UTxO on the chain, a Lock (or more specifically, a LockAddress) is provided.  When spending an existing UTxO from the chain, the corresponding Proof ("key") is provided.  Authorization validation ensures the Proof/key matches and is correct for the Lock.'}),"\n",(0,i.jsx)(t.p,{children:"The exact rules are defined in BramblSc and used directly in this protocol."}),"\n",(0,i.jsx)(t.h3,{id:"cost-and-rewards",children:"Cost and Rewards"}),"\n",(0,i.jsx)(t.p,{children:'Validating and performing bookkeeping for ledger transactions may be CPU/memory-intensive.  The amount of work required to include each transaction is captured in a score known as "Cost".  This cost is determined based on transaction size and estimated verification complexity. The resulting number does not correspond to a token quantity; it is just a number.  The calculation is defined in BramblSc and used directly in the protocol.'}),"\n",(0,i.jsx)(t.p,{children:'Because of the work involved with operating a block-producing blockchain node, block producers are rewarded for their efforts.  These rewards are captured as any "excess" tokens from each transaction included in their block.  For example, if a transaction spends/consumes 50 tokens but only creates 40 tokens, there are 10 excess tokens.  The block producer can claim this excess as a reward.'}),"\n",(0,i.jsx)(t.p,{children:"At this time, there is no enforced minimum/maximum cost/reward.  In the future, the two numbers could be combined to impose minimum fees."})]})}function h(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>a,a:()=>r});var i=n(7294);const s={},o=i.createContext(s);function r(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);