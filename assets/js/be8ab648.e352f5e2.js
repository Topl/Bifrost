"use strict";(self.webpackChunkbifrost_documentation=self.webpackChunkbifrost_documentation||[]).push([[185],{526:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>a});var n=s(5893),i=s(1151);const o={},r="Consensus",l={id:"concepts/consensus",title:"Consensus",description:"The set of rules that Block Producers must follow.",source:"@site/docs/concepts/consensus.md",sourceDirName:"concepts",slug:"/concepts/consensus",permalink:"/Bifrost/docs/current/concepts/consensus",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"conceptsSidebar",previous:{title:"Blockchain Core",permalink:"/Bifrost/docs/current/concepts/blockchain-core"},next:{title:"Ledger",permalink:"/Bifrost/docs/current/concepts/ledger"}},c={},a=[{value:"Core Responsibilities",id:"core-responsibilities",level:2},{value:"Header Validation",id:"header-validation",level:3},{value:"Eta",id:"eta",level:4},{value:"Eligibility",id:"eligibility",level:3},{value:"Chain Selection",id:"chain-selection",level:3}];function h(e){const t={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"consensus",children:"Consensus"}),"\n",(0,n.jsx)(t.p,{children:"The set of rules that Block Producers must follow."}),"\n",(0,n.jsx)(t.h2,{id:"core-responsibilities",children:"Core Responsibilities"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Validate block headers"}),"\n",(0,n.jsx)(t.li,{children:"Ensure eligibility of block producers"}),"\n",(0,n.jsx)(t.li,{children:"Select between two chain branches"}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"header-validation",children:"Header Validation"}),"\n",(0,n.jsx)(t.p,{children:'A blockchain is a sequence of "blocks", where each block contains a Header and a Body. Headers contain the information required to perform consensus operations. Each Header must satisfy a list of validation rules, including but not limited to:'}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:'The "height" must incrementally increase from the previous block'}),"\n",(0,n.jsx)(t.li,{children:'The Block Producer must be eligible at the block\'s "slot"'}),"\n",(0,n.jsx)(t.li,{children:'The "timestamp" must increase from the previous block and must correspond to the "slot"'}),"\n",(0,n.jsx)(t.li,{children:"The block must be produced by a registered staker"}),"\n",(0,n.jsx)(t.li,{children:'The block must include the correct "eta" value'}),"\n"]}),"\n",(0,n.jsx)(t.h4,{id:"eta",children:"Eta"}),"\n",(0,n.jsx)(t.p,{children:'Eta represents "epoch randomness".  It is a 32-byte array that is stamped on each header and changes at the turn of each epoch.'}),"\n",(0,n.jsx)(t.p,{children:"The updated value is calculated by taking the previous value and hashing it with the randomness (rho) values provided by each staker of the first 2/3 of the current epoch."}),"\n",(0,n.jsx)(t.h3,{id:"eligibility",children:"Eligibility"}),"\n",(0,n.jsxs)(t.p,{children:['This protocol uses a flavor of "proof-of-stake" known as Taktikos, which is derived from Ouroboros.  The protocol employs a separate "clock" which is made up of an infinite number of discrete chunks of time known as "slots" (i.e. "seconds"). Eligibility to produce the next block is determined on a slot-by-slot basis, although not all slots yield an eligibility. The protocol parameters are tuned in a way that aims for ',(0,n.jsx)(t.em,{children:"someone"})," to be eligible at a predictable frequency (i.e. once every 10 slots)."]}),"\n",(0,n.jsx)(t.p,{children:"Block Producers must first register before they can be considered eligible.  During registration, the block producer picks a (really big) random number which adds a bit of variability to the system.  Additionally, the block producer must set aside some portion of tokens to be used for staking.  The number of tokens set aside, relative to the rest of the block producers, scales the chances of eligibility. By setting aside more staking tokens, the block producer will be eligible more frequently."}),"\n",(0,n.jsx)(t.p,{children:"In this protocol, a block producer references a single UTxO containing both registration data and staking tokens.  When registering (creating the UTxO), the staker is not immediately eligible, thus preventing instability and fluctuation of the protocol. The staker must wait until the completion of the current epoch plus one additional epoch before becoming eligible.  As such, the consensus mechanism uses a separate stake tracking mechanism which tracks epoch boundaries and registrations."}),"\n",(0,n.jsx)(t.h3,{id:"chain-selection",children:"Chain Selection"}),"\n",(0,n.jsxs)(t.p,{children:["Not all slots are occupied by a block.  In most cases, the slot will be empty because no block producers were eligible at the specific time.  But on some rare occasions, ",(0,n.jsx)(t.em,{children:"multiple"}),' block producers may be eligible for a given slot. While both may be eligible, only one can be accepted.  Choosing between two eligible blocks is known as "chain selection".']}),"\n",(0,n.jsx)(t.p,{children:"The two types of rulesets are:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Standard Order"}),": The primary set of rules to apply to short branches/forks.","\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"The longest chain is selected (greatest height value)"}),"\n",(0,n.jsx)(t.li,{children:"If height is equal, the tip block with the lowest slot is selected"}),"\n",(0,n.jsx)(t.li,{children:"If the slot is equal, the tip block with the lowest BigInt representation of rhoNonceHash is selected"}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Density Order"}),": The backup set of rules to apply for long forks.","\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["If the branch/fork point is more than ",(0,n.jsx)(t.code,{children:"kLookback"})," number of blocks from the head of either chain, employ Density Order"]}),"\n",(0,n.jsx)(t.li,{children:"Find the common ancestor point between the two branches"}),"\n",(0,n.jsxs)(t.li,{children:["Count the number of blocks on each branch within ",(0,n.jsx)(t.code,{children:"sWindow"})," number of slots"]}),"\n",(0,n.jsx)(t.li,{children:"The chain with more blocks (thus greater density) is selected"}),"\n"]}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},1151:(e,t,s)=>{s.d(t,{Z:()=>l,a:()=>r});var n=s(7294);const i={},o=n.createContext(i);function r(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);